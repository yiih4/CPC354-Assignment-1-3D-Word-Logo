<!DOCTYPE html>
<html>
  <head>
    <title>3D Word Logo TV Ident (WebGL)</title>
    <script type="text/javascript" src="./webgl-utils.js"></script>
    <script type="text/javascript" src="./common/initShaders.js"></script>
    <script type="text/javascript" src="./common/MVnew.js"></script>
  </head>
  <body>
    <h1>3D Word Logo - Animated TV Ident</h1>
    <canvas id="gl-canvas" width="700" height="500"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
      #version 300 es
      in vec4 aPosition;
      in vec4 aColor;
      out vec4 vColor;
      uniform mat4 uMVP;

      void main() {
          vColor = aColor;
          gl_Position = uMVP * aPosition;
      }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
      #version 300 es
      precision mediump float;
      in vec4 vColor;
      out vec4 fColor;

      void main() {
          fColor = vColor;
      }
    </script>

    <script type="text/javascript">
      "use strict";

      // --- GLOBAL VARIABLES ---
      var gl;
      var program;
      var mvpMatrixLoc;

      // Objects to hold buffer data for shapes (L and O)
      var shapeL, shapeO;

      // Configuration
      const EXTRUSION_DEPTH = 0.5;
      const COLOR_L = vec4(0.8, 0, 0.2, 1.0); // Reddish
      const COLOR_O = vec4(0.2, 0.2, 0.6, 1.0); // Blueish

      let animSeq = 0; // Define animation sequence variables (0: right, 1: back, 2: left, 3: back, 4: scale-up)
      let theta = 0; // Rotation angle in degrees
      let scaleFactor = 1.0; // Scaling factor for the word logo
      const maxScale = 2.5; // Target scale for "full-screen" effect

      // --- INITIALIZATION ---

      window.onload = function init() {
        var canvas = document.getElementById("gl-canvas");
        gl = canvas.getContext("webgl2");
        if (!gl) {
          alert("WebGL 2.0 unavailable");
          return;
        }

        // Configure WebGL
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0.9, 0.9, 0.9, 1.0); // White background
        gl.enable(gl.DEPTH_TEST);

        // Load shaders
        program = initShaders(gl, "vertex-shader", "fragment-shader");
        gl.useProgram(program);

        mvpMatrixLoc = gl.getUniformLocation(program, "uMVP");

        // --- DEFINE GEOMETRY ---

        // Define 2D profile for 'L' (Counter-Clockwise)
        const vertices2D_L = [
          vec2(-0.5, -1.0), // 0: Bottom Left
          vec2(0.5, -1.0), // 1: Bottom Right
          vec2(0.5, -0.7), // 2: Inner Corner Right
          vec2(-0.2, -0.7), // 3: Inner Corner Left
          vec2(-0.2, 1.0), // 4: Top Right
          vec2(-0.5, 1.0), // 5: Top Left
        ];

        // Define 2D profile for 'O' (Counter-Clockwise)
        // Indices 0-3: Outer Box, 4-7: Inner Box (Hole)
        const vertices2D_O = [
          // Outer Box
          vec2(-0.5, -1.0), // 0: Bottom Left
          vec2(0.5, -1.0), // 1: Bottom Right
          vec2(0.5, 1.0), // 2: Top Right
          vec2(-0.5, 1.0), // 3: Top Left
          // Inner Box
          vec2(-0.2, -0.7), // 4: Inner Bottom Left
          vec2(0.2, -0.7), // 5: Inner Bottom Right
          vec2(0.2, 0.7), // 6: Inner Top Right
          vec2(-0.2, 0.7), // 7: Inner Top Left
        ];

        // Build Shapes
        shapeL = createExtrudedShape(
          vertices2D_L,
          EXTRUSION_DEPTH,
          COLOR_L,
          "L"
        );
        shapeO = createExtrudedShape(
          vertices2D_O,
          EXTRUSION_DEPTH,
          COLOR_O,
          "O"
        );

        // Render the scene
        render();
      };

      // --- GEOMETRY BUILDER ---

      function createExtrudedShape(vertices2D, depth, color, type) {
        var positions = [];
        var colors = [];
        var indices = [];
        var halfDepth = depth / 2.0;
        var vlength = vertices2D.length;

        // Generate Vertices
        // Front Face (z = +halfDepth = +0.25)
        for (let i = 0; i < vlength; i++) {
          positions.push(vec3(vertices2D[i][0], vertices2D[i][1], halfDepth));
          colors.push(color);
        }
        // Back Face (z = -halfDepth = -0.25)
        for (let i = 0; i < vlength; i++) {
          positions.push(vec3(vertices2D[i][0], vertices2D[i][1], -halfDepth));
          // Make back face slightly darker
          colors.push(
            vec4(color[0] * 0.5, color[1] * 0.5, color[2] * 0.5, 1.0)
          );
        }

        // Triangulation: Generate Indices
        if (type === "L") {
          // Front Face
          indices.push(0, 1, 3);
          indices.push(1, 2, 3);
          indices.push(0, 3, 5);
          indices.push(3, 4, 5);

          // Back Face (Offset by vlength, reverse winding order)
          indices.push(vlength + 0, vlength + 3, vlength + 1);
          indices.push(vlength + 1, vlength + 3, vlength + 2);
          indices.push(vlength + 0, vlength + 5, vlength + 3);
          indices.push(vlength + 3, vlength + 5, vlength + 4);

          // Side Faces (Standard loop)
          generateSideIndices(indices, vlength);
        } else if (type === "O") {
          // Front Face (4 trapezoids connecting outer to inner)
          pushQuad(indices, 0, 1, 5, 4); // Bottom
          pushQuad(indices, 1, 2, 6, 5); // Right
          pushQuad(indices, 2, 3, 7, 6); // Top
          pushQuad(indices, 3, 0, 4, 7); // Left

          // Back Face (Offset by vlength, reverse winding)
          pushBackQuad(indices, 0, 1, 5, 4, vlength);
          pushBackQuad(indices, 1, 2, 6, 5, vlength);
          pushBackQuad(indices, 2, 3, 7, 6, vlength);
          pushBackQuad(indices, 3, 0, 4, 7, vlength);

          // Side Faces
          // External Loop (0->1->2->3->0)
          generateSideLoop(indices, 0, 4, vlength);
          // Internal Loop (4->5->6->7->4)
          generateSideLoop(indices, 4, 4, vlength);
        }

        // Create and bind WebGL buffers
        var pBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, pBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, flatten(positions), gl.STATIC_DRAW);

        var cBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, flatten(colors), gl.STATIC_DRAW);

        var iBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iBuffer);
        gl.bufferData(
          gl.ELEMENT_ARRAY_BUFFER,
          new Uint16Array(indices),
          gl.STATIC_DRAW
        );

        // Return the object containing buffer info
        return {
          pBuffer: pBuffer,
          cBuffer: cBuffer,
          iBuffer: iBuffer,
          count: indices.length,
        };
      }

      // --- HELPER FUNCTIONS for Triangulation ---

      // Helper to generate side faces for letter 'L'
      function generateSideIndices(indices, n) {
        for (let i = 0; i < n; i++) {
          let next = (i + 1) % n;
          // Front vertices: i, next
          // Back vertices: i+N, next+N
          // Two triangles to form the rectangular side face
          indices.push(i, next, i + n);
          indices.push(next, next + n, i + n);
        }
      }

      // Helper to generate side faces for letter 'O'
      function generateSideLoop(indices, startIndex, loopCount, n) {
        for (let i = 0; i < loopCount; i++) {
          let curr = startIndex + i;
          let next = startIndex + ((i + 1) % loopCount);

          indices.push(curr, next, curr + n);
          indices.push(next, next + n, curr + n);
        }
      }

      // Helper to push a quad (2 triangles)
      function pushQuad(indices, a, b, c, d) {
        indices.push(a, b, c);
        indices.push(a, c, d);
      }

      // Helper to push a back face quad (2 triangles) with reversed winding
      function pushBackQuad(indices, a, b, c, d, vlength) {
        indices.push(vlength + a, vlength + d, vlength + c);
        indices.push(vlength + a, vlength + c, vlength + b);
      }

      // --- RENDERING ---

      function render() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Setup Camera
        const V = lookAt(vec3(1, 4, 9), vec3(0, 0, 0), vec3(0, 1, 0));
        const P = perspective(45, gl.canvas.width / gl.canvas.height, 0.1, 100);
        const VP = mult(P, V);

        defaultAnim();

        // Apply rotation around Z-axis and scale the word logo
        let M = mult(rotateZ(theta), scale(scaleFactor, scaleFactor, 1));

        // Translate word to center
        M = mult(translate(0, 0, 0), M); // if needed, you can move the center

        // Draw shapes with rotated matrix
        drawShape(shapeL, mult(VP, mult(M, translate(-1.5, 0, 0)))); // Left L
        drawShape(shapeO, mult(VP, mult(M, translate(0, 0, 0)))); // O
        drawShape(shapeL, mult(VP, mult(M, translate(1.5, 0, 0)))); // Right L

        // Animate
        requestAnimationFrame(render);
      }

      function drawShape(shape, mvpMatrix) {
        // Bind position buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, shape.pBuffer);
        var positionLoc = gl.getAttribLocation(program, "aPosition");
        gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionLoc);

        // Bind color buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, shape.cBuffer);
        var colorLoc = gl.getAttribLocation(program, "aColor");
        gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(colorLoc);

        // Bind index buffer
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, shape.iBuffer);

        // Send Matrix Uniform
        gl.uniformMatrix4fv(mvpMatrixLoc, false, flatten(mvpMatrix));

        // Draw Elements (Indexed Drawing)
        gl.drawElements(gl.TRIANGLES, shape.count, gl.UNSIGNED_SHORT, 0);
      }

      // Handles the animation sequence of the word logo
      function defaultAnim() {
        switch (animSeq) {
          case 0: // Rotate to the right by 180 degrees
            theta -= 1;
            if (theta <= -180) animSeq = 1;
            break;

          case 1: // Rotate back to original
            theta += 1;
            if (theta >= 0) animSeq = 2;
            break;

          case 2: // Rotate to the left by 180 degrees
            theta += 1;
            if (theta >= 180) animSeq = 3;
            break;

          case 3: // Rotate back to original
            theta -= 1;
            if (theta <= 0) animSeq = 4;
            break;

          case 4: // Gradually enlarge the word logo to full-screen size
            if (scaleFactor < maxScale) {
              scaleFactor += 0.01; // Increment added to scaleFactor each frame for smooth scaling
            }
            break;
        }
      }
    </script>
  </body>
</html>
