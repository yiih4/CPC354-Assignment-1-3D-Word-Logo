<!DOCTYPE html>
<html>
  <head>
    <title>3D Word Logo TV Ident (WebGL)</title>
    <script type="text/javascript" src="./webgl-utils.js"></script>
    <script type="text/javascript" src="./common/initShaders.js"></script>
    <script type="text/javascript" src="./common/MVnew.js"></script>
  </head>
  <body>
    <h1>3D Word Logo - Animated TV Ident</h1>
    <canvas id="gl-canvas" width="700" height="500"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
      #version 300 es
      in vec4 aPosition;
      in vec4 aColor;
      out vec4 vColor;
      uniform mat4 uMVP;

      void main() {
          vColor = aColor;
          gl_Position = uMVP * aPosition;
      }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
      #version 300 es
      precision mediump float;
      in vec4 vColor;
      out vec4 fColor;

      void main() {
          fColor = vColor;
      }
    </script>

    <script type="text/javascript">
      "use strict";

      // --- GLOBAL VARIABLES ---

      var gl;
      var program;
      var mvpMatrixLoc;
      var shapeL, shapeO;
      const EXTRUSION_DEPTH = 0.5;
      const COLOR_L = vec4(0.8, 0, 0.2, 1.0); 
      const COLOR_O = vec4(0.2, 0.2, 0.6, 1.0); 

      // --- INITIALIZATION ---

      window.onload = function init() {
        var canvas = document.getElementById("gl-canvas");
        gl = canvas.getContext("webgl2");
        if (!gl) {
          alert("WebGL 2.0 unavailable");
          return;
        }

        // Set up WebGL
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(1.0, 1.0, 1.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        // Load shaders
        program = initShaders(gl, "vertex-shader", "fragment-shader");
        gl.useProgram(program);

        mvpMatrixLoc = gl.getUniformLocation(program, "uMVP");

        // --- DEFINE GEOMETRY ---

        // Define 2D face for 'L' (Counter-Clockwise)
        const vertices2D_L = [
          vec2(-0.5, -1.0), // 0: bottom left
          vec2(0.5, -1.0), // 1: bottom right
          vec2(0.5, -0.7), // 2: inner corner right
          vec2(-0.2, -0.7), // 3: inner corner left
          vec2(-0.2, 1.0), // 4: top right
          vec2(-0.5, 1.0), // 5: top left
        ];

        // Define 2D face for 'O' (Counter-Clockwise)
        const vertices2D_O = [
          // Outer box
          vec2(-0.5, -1.0), // 0: bottom left
          vec2(0.5, -1.0), // 1: bottom right
          vec2(0.5, 1.0), // 2: top right
          vec2(-0.5, 1.0), // 3: top left
          // Inner box
          vec2(-0.2, -0.7), // 4: inner bottom left
          vec2(0.2, -0.7), // 5: inner bottom right
          vec2(0.2, 0.7), // 6: inner top right
          vec2(-0.2, 0.7), // 7: inner top left
        ];

        // Build shapes
        shapeL = createExtrudedShape(
          vertices2D_L,
          EXTRUSION_DEPTH,
          COLOR_L,
          "L"
        );
        shapeO = createExtrudedShape(
          vertices2D_O,
          EXTRUSION_DEPTH,
          COLOR_O,
          "O"
        );

        // Render the scene
        render();
      };

      // --- BUILD GEOMETRY ---

      function createExtrudedShape(vertices2D, depth, color, type) {
        var positions = [];
        var colors = [];
        var indices = [];
        var halfDepth = depth / 2.0;
        var vlength = vertices2D.length;

        // Generate vertices
        // Front face (z = +halfDepth)
        for (let i = 0; i < vlength; i++) {
          positions.push(vec3(vertices2D[i][0], vertices2D[i][1], halfDepth));
          colors.push(color);
        }
        // Back face (z = -halfDepth)
        for (let i = 0; i < vlength; i++) {
          positions.push(vec3(vertices2D[i][0], vertices2D[i][1], -halfDepth));
          // Make back face darker
          colors.push(
            vec4(color[0] * 0.5, color[1] * 0.5, color[2] * 0.5, 1.0)
          );
        }

        // Triangulation: Generate indices 
        if (type === "L") {
          // Front face
          indices.push(0, 1, 3);
          indices.push(1, 2, 3);
          indices.push(0, 3, 5);
          indices.push(3, 4, 5);

          // Back face (offset by vlength, reverse winding order)
          indices.push(vlength + 0, vlength + 3, vlength + 1);
          indices.push(vlength + 1, vlength + 3, vlength + 2);
          indices.push(vlength + 0, vlength + 5, vlength + 3);
          indices.push(vlength + 3, vlength + 5, vlength + 4);

          // Side faces
          generateSideIndices(indices, vlength);
        } else if (type === "O") {
          // Front face
          pushQuad(indices, 0, 1, 5, 4); // Bottom
          pushQuad(indices, 1, 2, 6, 5); // Right
          pushQuad(indices, 2, 3, 7, 6); // Top
          pushQuad(indices, 3, 0, 4, 7); // Left

          // Back face (offset by vlength, reverse winding order)
          pushBackQuad(indices, 0, 1, 5, 4, vlength);
          pushBackQuad(indices, 1, 2, 6, 5, vlength);
          pushBackQuad(indices, 2, 3, 7, 6, vlength);
          pushBackQuad(indices, 3, 0, 4, 7, vlength);

          // Side faces
          // Outer box Loop (0->1->2->3->0)
          generateSideLoop(indices, 0, 4, vlength);
          // Inner box Loop (4->5->6->7->4)
          generateSideLoop(indices, 4, 4, vlength);
        }

        // Create and bind WebGL buffers
        var pBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, pBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, flatten(positions), gl.STATIC_DRAW);

        var cBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, flatten(colors), gl.STATIC_DRAW);

        var iBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iBuffer);
        gl.bufferData(
          gl.ELEMENT_ARRAY_BUFFER,
          new Uint16Array(indices),
          gl.STATIC_DRAW
        );

        // Return the object containing buffer info
        return {
          pBuffer: pBuffer,
          cBuffer: cBuffer,
          iBuffer: iBuffer,
          count: indices.length,
        };
      }

      // --- HELPER FUNCTIONS for Triangulation ---

    // Helper to generate side faces for letter 'L'
      function generateSideIndices(indices, n) {
        for (let i = 0; i < n; i++) {
          let next = (i + 1) % n;
          // Front vertices: i, next
          // Back vertices: i+N, next+N
          // Two triangles to form the rectangular side face
          indices.push(i, next, i + n);
          indices.push(next, next + n, i + n);
        }
      }

      // Helper to generate side faces for letter 'O'
      function generateSideLoop(indices, startIndex, loopCount, n) {
        for (let i = 0; i < loopCount; i++) {
          let curr = startIndex + i;
          let next = startIndex + ((i + 1) % loopCount);

          indices.push(curr, next, curr + n);
          indices.push(next, next + n, curr + n);
        }
      }

      // Helper to push a quad (2 triangles)
      function pushQuad(indices, a, b, c, d) {
        indices.push(a, b, c);
        indices.push(a, c, d);
      }

      // Helper to push a back face quad (2 triangles) with reverse winding
      function pushBackQuad(indices, a, b, c, d, vlength) {
        indices.push(vlength + a, vlength + d, vlength + c);
        indices.push(vlength + a, vlength + c, vlength + b);
      }

      // --- RENDERING ---

      function render() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Setup camera (View and Projection)
        const V = lookAt(vec3(3, 4, 6), vec3(0, 0, 0), vec3(0, 1, 0));  // eye, at, up
        const P = perspective(45, gl.canvas.width / gl.canvas.height, 0.1, 100); // fovy, aspect (w/h), near, far
        const VP = mult(P, V);

        // Draw first 'L' (translate left)
        let M = translate(-1.5, 0.0, 0.0);
        drawShape(shapeL, mult(VP, M));

        // Draw 'O' (center)
        M = translate(0.0, 0.0, 0.0);
        drawShape(shapeO, mult(VP, M));

        // Draw second 'L' (translate right)
        M = translate(1.5, 0.0, 0.0);
        drawShape(shapeL, mult(VP, M));

        // Note: add requestAnimationFrame for animation if needed
      }

      function drawShape(shape, mvpMatrix) {
        // Bind position buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, shape.pBuffer);
        var positionLoc = gl.getAttribLocation(program, "aPosition");
        gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionLoc);

        // Bind color buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, shape.cBuffer);
        var colorLoc = gl.getAttribLocation(program, "aColor");
        gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(colorLoc);

        // Bind index buffer
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, shape.iBuffer);

        // Send matrix uniform
        gl.uniformMatrix4fv(mvpMatrixLoc, false, flatten(mvpMatrix));

        // Draw elements (indexed drawing)
        gl.drawElements(gl.TRIANGLES, shape.count, gl.UNSIGNED_SHORT, 0);
      }
    </script>
  </body>
</html>
