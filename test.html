<!DOCTYPE html>
<html>
<head>
    <title>3D Word Logo TV Ident (WebGL)</title>
    <script type="text/javascript" src="./webgl-utils.js"></script>
    <script type="text/javascript" src="./common/initShaders.js"></script>
    <script type="text/javascript" src="./common/MVnew.js"></script> 
</head>
<body>

    <h1>3D Word Logo Controls</h1>
    <div id="controls">
        <label for="depthSlider">Extrusion Depth:</label>
        <input type="range" id="depthSlider" min="0.1" max="1.0" step="0.05" value="0.3">
        <span id="depthValue">0.3</span>

        <br>

        <label for="speedSlider">Animation Speed:</label>
        <input type="range" id="speedSlider" min="0.001" max="0.1" step="0.001" value="0.02">
        <span id="speedValue">0.02</span>

        <br>

        <label for="colorPicker">Logo Color:</label>
        <input type="color" id="colorPicker" value="#802020">
    </div>

    <canvas id="gl-canvas" width="600" height="600"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
        #version 300 es

        in vec4 aPosition;
        in vec4 aColor;
        out vec4 vColor;

        uniform mat4 uMVP;

        void main() {
            vColor = aColor;
            gl_Position = uMVP * aPosition; 
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        #version 300 es

        precision mediump float;
        in vec4 vColor;
        out vec4 fColor;

        void main() {
            fColor = vColor;
        }
    </script>

    <script type="text/javascript">
"use strict";

// --- Global Variables ---
var gl;
var program;
var positions = []; // 3D vertices
var indices = [];   // Indices for drawing triangles
var colors = [];    // Colors for each vertex
var numVertices;    // Total number of indices to draw

var mvpMatrixLoc;   // Uniform location for MVP matrix

// UI Controlled Variables
var extrusionDepth = 0.3; // Initial depth
var animationSpeed = 0.02; // Initial speed
var logoColor = [0.5, 0.125, 0.125, 1.0]; // Initial color (R: 128, G: 32, B: 32)

// Animation State Variables
var rotationAngle = 0.0; 

// Base 2D Vertices for the letter 'L' (6 points, centered)
// This is the front face's CCW order
const vertices2D_L = [
    vec2(-1.0, -1.5),
    vec2(1.0,  -1.5),
    vec2(1.0, -1.0),
    vec2(-0.5, -1.0),
    vec2(-0.5, 1.5),
    vec2(-1.0, 1.5)
];

// --- Initialization ---

window.onload = function init() {
    var canvas = document.getElementById("gl-canvas");
    gl = canvas.getContext('webgl2'); 
    if (!gl) {
        alert("WebGL 2.0 isn't available");
        return;
    }

    // Configure WebGL
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(1.0, 1.0, 1.0, 1.0); // White background
    gl.enable(gl.DEPTH_TEST);

    // Load shaders and initialize program
    program = initShaders(gl, "vertex-shader", "fragment-shader");
    gl.useProgram(program);

    // Get uniform location
    mvpMatrixLoc = gl.getUniformLocation(program, "uMVP");
    
    // Generate the initial 3D geometry
    generate3DGeometry(vertices2D_L, extrusionDepth, logoColor);

    // Setup Buffers and Attributes
    setupBuffers();

    // Setup UI Controls
    setupUI();

    // Start the animation loop
    animate();
};

// --- Geometry Generation (Objective (i) & (iii)) ---

/**
 * Generates the 3D geometry for the letter (L) by extruding the 2D vertices.
 * Populates global positions, colors, and indices arrays.
 */
function generate3DGeometry(vertices2D, depth, color) {
    // Clear previous data
    positions = [];
    indices = [];
    colors = [];

    const halfDepth = depth / 2.0;
    const N = vertices2D.length; // 6 for the letter 'L'
    
    // 1. Generate Front and Back Face Vertices
    for (let i = 0; i < N; i++) {
        // Front face (z = +halfDepth)
        positions.push(vec3(vertices2D[i][0], vertices2D[i][1], halfDepth));
        colors.push(color);
        
        // Back face (z = -halfDepth) - offset index by N
        positions.push(vec3(vertices2D[i][0], vertices2D[i][1], -halfDepth));
        colors.push(color);
    }
    
    // 2. Front Face Indices (Triangulation: T1, T2, T3, T4 based on example)
    // Vertices: 0, 2, 4, 6, 8, 10
    // L-shape: T1(0, 2, 6), T2(2, 4, 6), T3(6, 8, 10), T4(6, 10, 0)
    // Using simple L-triangulation from the previous example (vertices 0-5)
    // T1(0, 1, 3), T2(1, 2, 3), T3(3, 4, 5), T4(3, 5, 0)
    
    // Front indices (using the 0, 2, 4, 6... indices from positions array)
    indices.push(0, 2, 6);
    indices.push(2, 4, 6);
    indices.push(6, 8, 10);
    indices.push(6, 10, 0);

    // 3. Back Face Indices (Clockwise order for correct culling/rendering)
    // Vertices: 1, 3, 5, 7, 9, 11
    // CW for back: T1(1, 7, 3), T2(3, 7, 5), T3(7, 11, 9), T4(7, 1, 11)
    indices.push(1, 7, 3);
    indices.push(3, 7, 5);
    indices.push(7, 11, 9);
    indices.push(7, 1, 11);

    // 4. Side Faces Indices (N * 2 triangles)
    for (let i = 0; i < N; i++) {
        let i_next = (i + 1) % N;
        
        // Front vertices indices: i*2 and i_next*2
        const vF1 = i * 2;
        const vF2 = i_next * 2;
        
        // Back vertices indices: i*2 + 1 and i_next*2 + 1
        const vB1 = i * 2 + 1;
        const vB2 = i_next * 2 + 1;
        
        // First side triangle (vF1, vF2, vB1)
        indices.push(vF1, vF2, vB1);
        
        // Second side triangle (vF2, vB2, vB1)
        indices.push(vF2, vB2, vB1);
    }

    numVertices = indices.length;
}

/**
 * Creates, binds, and loads all WebGL buffers.
 */
function setupBuffers() {
    // 1. Position Buffer (3D: x, y, z)
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, flatten(positions), gl.STATIC_DRAW);

    const positionLoc = gl.getAttribLocation(program, "aPosition");
    gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(positionLoc);

    // 2. Color Buffer (4D: r, g, b, a)
    const colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, flatten(colors), gl.STATIC_DRAW);

    const colorLoc = gl.getAttribLocation(program, "aColor");
    gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(colorLoc);

    // 3. Index Buffer (defines triangle connectivity)
    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
}

// --- UI Controls (Objective (ii)) ---

function setupUI() {
    // Extrusion Depth Control
    document.getElementById('depthSlider').oninput = function(e) {
        extrusionDepth = parseFloat(e.target.value);
        document.getElementById('depthValue').textContent = extrusionDepth.toFixed(2);
        
        // Regenerate geometry and re-buffer data when depth changes
        generate3DGeometry(vertices2D_L, extrusionDepth, logoColor);
        setupBuffers(); 
    };

    // Animation Speed Control
    document.getElementById('speedSlider').oninput = function(e) {
        animationSpeed = parseFloat(e.target.value);
        document.getElementById('speedValue').textContent = animationSpeed.toFixed(3);
    };

    // Color Picker Control
    document.getElementById('colorPicker').onchange = function(e) {
        const hex = e.target.value;
        // Convert hex to [r, g, b, 1.0] array
        const r = parseInt(hex.substring(1, 3), 16) / 255.0;
        const g = parseInt(hex.substring(3, 5), 16) / 255.0;
        const b = parseInt(hex.substring(5, 7), 16) / 255.0;
        logoColor = [r, g, b, 1.0];

        // Regenerate geometry and re-buffer data with new color
        generate3DGeometry(vertices2D_L, extrusionDepth, logoColor);
        setupBuffers();
    };
}

// --- Animation & Rendering (Objective (i)) ---

function animate() {
    // 1. Calculate the Model Matrix (M) - Simple continuous rotation for now
    // This will be replaced by the 6-stage sequence in the final version.
    rotationAngle += animationSpeed * 50; // Scale speed to make it visible
    rotationAngle %= 360; 

    // M: Rotate the logo around the Y-axis (vertical)
    let M = rotateY(rotationAngle); 

    // 2. View Matrix (V) - Camera position
    const V = lookAt(
        vec3(0, 0, -8),  // Camera position (z=-8 to look into the screen)
        vec3(0, 0, 0),   // Point to look at (center of the logo)
        vec3(0, 1, 0)    // Up vector
    );

    // 3. Projection Matrix (P) - Perspective
    const canvas = gl.canvas;
    const P = perspective(
        45,                      // FOV in degrees
        canvas.width / canvas.height, // Aspect ratio
        0.1,                     // Near clipping plane
        100                      // Far clipping plane
    );

    // 4. Combine: MVP = P * V * M
    const MVP = mult(P, mult(V, M));

    // 5. Send the matrix to the shader
    gl.uniformMatrix4fv(mvpMatrixLoc, false, flatten(MVP));

    // 6. Clear and Draw
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 
    
    // Draw using gl.drawElements (drawing with indices)
    if (numVertices > 0) {
        gl.drawElements(gl.TRIANGLES, numVertices, gl.UNSIGNED_SHORT, 0); 
    }
    
    // 7. Loop
    requestAnimationFrame(animate);
}
    </script>
</body>
</html>